#### load required libraries ####
package.list=c("ubms",
               "usdm",
               "rstan",
               "camtrapR",
               "readxl",
               "data.table"
               )

for (package in package.list) {
  if (!require(package, character.only = T, quietly = T)) {
    install.packages(package)
    library(package, character.only = T)
  }
}



## Set the working directory.
wd <- "./Input_data"
setwd(wd)



# load input data for modelling
# Load the site covariates from CSV
Site_Covs_all <- read.csv("./Covariates/SiteCovs/Site_covs.csv", row.names="station")
Site_Covs_all <- Site_Covs_all[order(row.names(Site_Covs_all)),]
names(Site_Covs_all)
colnames(Site_Covs_all)[colnames(Site_Covs_all)=="LCP_mean"] <- "LCP"
colnames(Site_Covs_all)[colnames(Site_Covs_all)=="elevation"] <- "ele"
colnames(Site_Covs_all)[colnames(Site_Covs_all)=="village_heatmap20"] <- "vill"


# We need to standardize all continuous covariates by using the scale() command
str(Site_Covs_all)
head(Site_Covs_all)
Site_Covs_all$site <- relevel(as.factor(Site_Covs_all$site),ref="PMNP")


# Use scale-function to scale the continuous variables.
Site_Covs_all1 <- as.data.frame(scale(Site_Covs_all[,-c(1)]))
names(Site_Covs_all1) <- paste0("scale.", names(Site_Covs_all1))
Site_Covs_all <- cbind (Site_Covs_all, Site_Covs_all1)


# Load observation/detection covariates. Here we have effort and sites
# Load the effort
effort <- as.matrix(read.csv("./Covariates/ObsCovs/Effort/species.csv", row.names=1))
effort <- effort[order(row.names(effort)),]


# Load site as detection covariate
sites_detection <- as.matrix(read.csv("./Covariates/ObsCovs/Site/species__site_det.csv", row.names=1))
sites_detection <- sites_detection[order(row.names(sites_detection)),]



# Load the detection history that was generated by camtrapr
detecthist <- as.matrix(read.csv("./Detection_history/species__detection_history.csv",row.names = 1))
detecthist <- detecthist[order(row.names(detecthist)),]


# COVARIATE DATA MUST HAVE SAME TRAPPING SITES AS THE DETECTION HISTORY! NOT MORE! check the first dimension and rownames
dim(effort)
dim(detecthist)
dim(Site_Covs_all)
dim(sites_detection)


# Collinearity test between the covariates
library(usdm)
str(Site_Covs_all)
cor<- vifcor(Site_Covs_all[,-1], th=0.7)
cor


#Clean up the a bit: Here we remove NAs and clean up the data a bit
NAs <- apply(Site_Covs_all, 1, function(x){any(is.na(x))})
sum(NAs)
#Site_Covs_all <- Site_Covs_all[!NAs,]





# Shorter column names
Site_Covs_all_short <- Site_Covs_all
colnames(Site_Covs_all_short) <- gsub("scale.", "s_", colnames(Site_Covs_all_short))
colnames(Site_Covs_all_short) <- c("site",   "LCP",    "ele",    "vill",   "L",  "E",  "V")


umf <- unmarkedFrameOccu(y = detecthist,
                         siteCovs =  Site_Covs_all_short,
                         obsCovs = list(Effort=effort,
                                        Sites=sites_detection))





# Run three candidate models
n_cores = 4
n_iter = 5000

# null model
o_mul00 <- stan_occu(~ Effort ~ 1,
                     data = umf,
                     chains = n_cores,
                     cores = n_cores,
                     iter = n_iter)


# fixed effects of all covariates (without site):
o_mul_01 <- stan_occu(~ Effort ~ L+E+V,
                      data = umf,
                      chains = n_cores,
                      cores = n_cores,
                      iter = n_iter)


#random effect of site on all covariates (without fixed effects)
o_mul_04 <- stan_occu(~ Effort ~ (L+E+V||site),
                      data = umf,
                      #control = list(adapt_delta = 0.99, max_treedepth = 20),
                      chains = n_cores,
                      cores = n_cores,
                      iter = n_iter)






#FIT LIST
fms_mul.area <- fitList(
  'p(effort) psi(.)' = o_mul00,
  'p(effort) psi(L+E+V)' = o_mul_01,
  'p(effort) psi(L+E+V||site)' = o_mul_04
)

# rank candidate model
modsel_occu <-modSel(fms_mul.area)
round(modsel_occu, 3)

loo(o_mul_04)
loo(o_mul_01)
loo(o_mul00)

# Check the modedl perfomance
# Check Rhat
o_mul_04
o_mul_01
o_mul00



# check the traceplot of the chains
# which model to plot?
model_to_plot <- o_mul_04
name_model_to_plot <- "01_o_mul_04_random_effect_modelT"
#name_model_to_plot <- "02_o_mul_01_fixed_effect_model"
#name_model_to_plot <- "03_o_mul_00_null_model"

# create output directory for current model
wd_plots <- file.path("Traceplot", name_model_to_plot)

dir.create(wd_plots)

# define file names for plots
filename1_traceplot_lp <- "1_traceplot_lp.png"
filename2_traceplots_param_prefix <- "2_traceplot_"
filename3_histogram_param_prefix <- "3_histogram_"


# 1 plot log posterior
trace_lp <- ubms::traceplot(model_to_plot@stanfit, "lp__", inc_warmup=TRUE)   # doesn't work with mfrow or layout, so save one by one
ggsave(file.path(wd_plots, filename1_traceplot_lp))

# 2 : trace plots
stuff.to.plot <- names(rstan::extract(model_to_plot@stanfit))
inc_warmup <- TRUE
#stuff.to.plot <- c("beta_state", "b_state", "sigma_state", "beta_det")

for(i in stuff.to.plot) {
  if(i == "log_lik" | i == "lp__") next
  p <- rstan::traceplot(model_to_plot@stanfit, i, inc_warmup = inc_warmup)

  ggsave(file.path(wd_plots, paste0(filename2_traceplots_param_prefix, i, ".png")), plot = p,
         width = 8, height = 5, dpi = 150, scale = 2, type = "cairo")
}

# 3 Histograms
for(i in stuff.to.plot) {
  if(i == "log_lik") next

  # bayesplot function
  #p <- mcmc_hist(model_to_plot@stanfit, pars = names(model_to_plot)[1:5])

  ## rstan plotting function
  p <- stan_hist(model_to_plot@stanfit, i, bins = 100)

  ggsave(file.path(wd_plots, paste0(filename3_histogram_param_prefix, i, ".png")), plot = p,
         width = 8, height = 5, dpi = 150, scale = 2, type = "cairo")
}




#### Plot Coefficient
#For the random effect
model_to_plot <- o_mul_04
all_names <- names(model_to_plot)
posterior <- as.matrix(model_to_plot@stanfit)

# subset to one covariate only
all_names_subset <- all_names[grep("b_state[L ", all_names, fixed = TRUE)] #Thanh: this is for the random/mixed effect only

# subset posterior matrix to that covariate only
posterior_subset <- posterior[,all_names_subset]


# subset to one covariate only
covariate_short <- c("L", "E", "V")
names_to_match <- paste0("b_state[", covariate_short, " ")

all_names_subset <- lapply(names_to_match, FUN = grep, all_names, fixed = TRUE)

# subset posterior matrix to that covariate only
posterior_subset_df <- lapply(all_names_subset, FUN = function(x) as.data.frame(posterior[,x]))


# calculate statistics for each parameter
# calculate statistics for each parameter
tmp <- lapply(posterior_subset_df, FUN = function(x) {
  do.call(rbind, list(
    min = apply(x, 2, min),
    lower95 = apply(x, 2, quantile, 0.025),    # lower boundary of 95% BCI
    lower75 = apply(x, 2, quantile, 0.125),    # lower boundary of 75% BCI
    lower50 = apply(x, 2, quantile, 0.25),     # lower boundary of 50% BCI
    median = apply(x, 2, median),
    mean = apply(x, 2, mean),
    upper50 = apply(x, 2, quantile, 0.75),     # upper boundary of 50% BCI
    upper75 = apply(x, 2, quantile, 0.875),    # upper boundary of 75% BCI
    upper95 = apply(x, 2, quantile, 0.975),    # upper boundary of 95% BCI
    max = apply(x, 2, max)))
}
)

# assign covariate name to list with statistics
names(tmp) <- covariate_short

# modify column names to keep only the study area name
tmp2 <- lapply(tmp, FUN = function(x) {
  colnames(x) <- substr(colnames(x), start = 16, stop = nchar(colnames(x)) - 1 )
  x
})



# transform and bring in shape for ggplot
tmp2a <- lapply(tmp2, t)
tmp2b <- lapply(tmp2a, as.data.frame)
tmp2c <- lapply(tmp2b, FUN = function(x){
  x$area <- rownames(x)
  x})
tmp5 <- as.data.frame(rbindlist(tmp2c, idcol = "covariate"))

# give proper labels to reserves (rev is to make sure they are plotted in the order shown in levels)
tmp5$area <- factor(tmp5$area,
                    levels = rev(c("PMNP", "PDNR", "XeSap", "Saola", "BachMa", "STNR")),
                    labels = rev(c("Pu Mat NP", "Phong Dien NR", "Xe Sap NPA", "Saola NRs", "Bach Ma NP", "Song Thanh NR")))

# give proper labels to values in covariate column
tmp5$covariate <- factor(tmp5$covariate, levels = c("E", "L", "V"), labels = c("Elevation", "Least cost path", "Village density"))


# add color information
notbetween95 <- which(!between(0, tmp5$lower95, tmp5$upper95))    # group 1: 95%BCI does not overlap 0 -> red
between95 <- which(between(0, tmp5$lower95, tmp5$upper95))        # group 2: 95%BCI overlaps 0, 75%, or 50% does not overlaps 0  -> black
between75 <- which(between(0, tmp5$lower75, tmp5$upper75))        # group 3: 50%BCI overlaps 0         -> grey


tmp5$level <- NA
tmp5$level [notbetween95] <- 1
tmp5$level [between95] <- 2
tmp5$level [between75] <- 3

# define color values as Hex colors
level <-  rev(c("#A9A9A9", "#000000", "#FF0000")) # grey - black - red

# assign colors in data frame
tmp5$color <- level[tmp5$level]


# plot
p1 <- ggplot(tmp5, mapping = aes(y = median, x = area, group=covariate)) +
  ylim(-3,3)+
  labs(x = "", y = "")+
  geom_hline(yintercept=0, linetype="dashed", color = "grey",size=0.5) +
  geom_pointrange(aes(ymin = lower95, ymax = upper95), size=1, fatten = 5, color=tmp5$color, shape=10) +
  geom_errorbar(aes(ymin = lower75, ymax = upper75), width=0, size=2.2, color=tmp5$color) +     # plotting 75% BCI - as in Andrew's paper
  facet_wrap(facets = ~covariate) +
  theme_bw() +
  coord_flip()+
  theme(axis.title.x=element_text(size=14, vjust=0.5,hjust=0.5),
        axis.ticks.y=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.x=element_text(size=18, angle = 0,vjust=0.3,hjust=1),
        axis.text.y=element_blank(),
        legend.position='bottom',
        panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank(),
        strip.text.x = element_text(size = 30, colour = "black", angle = 00),
        panel.grid.minor.x = element_blank()
  );p1




##for the fixed effect
model_to_plot <- o_mul_01
all_names <- names(model_to_plot)
posterior <- as.matrix(model_to_plot@stanfit)

# subset to one covariate only
all_names_subset <- all_names[grep("beta_state[L", all_names, fixed = TRUE)]

# subset posterior matrix to that covariate only
posterior_subset <- posterior[,all_names_subset]


# subset to one covariate only
covariate_short <- c("L", "E", "V")
names_to_match <- paste0("beta_state[", covariate_short, "")

all_names_subset <- lapply(names_to_match, FUN = grep, all_names, fixed = TRUE)

# subset posterior matrix to that covariate only
posterior_subset_df <- lapply(all_names_subset, FUN = function(x) as.data.frame(posterior[,x]))


# calculate statistics for each parameter
tmp <- lapply(posterior_subset_df, FUN = function(x) {
  do.call(rbind, list(
    min = apply(x, 2, min),
    lower95 = apply(x, 2, quantile, 0.025),    # lower boundary of 95% BCI
    lower75 = apply(x, 2, quantile, 0.125),    # lower boundary of 75% BCI
    lower50 = apply(x, 2, quantile, 0.25),     # lower boundary of 50% BCI
    median = apply(x, 2, median),
    mean = apply(x, 2, mean),
    upper50 = apply(x, 2, quantile, 0.75),     # upper boundary of 50% BCI
    upper75 = apply(x, 2, quantile, 0.875),    # upper boundary of 75% BCI
    upper95 = apply(x, 2, quantile, 0.975),    # upper boundary of 95% BCI
    max = apply(x, 2, max)))
}
)

# assign covariate name to list with statistics
names(tmp) <- covariate_short

# modify column names to keep only the study area name
tmp2 <- lapply(tmp, FUN = function(x) {
  colnames(x) <- substr(colnames(x), start = 16, stop = nchar(colnames(x)) - 1 )
  x
})



# transform and bring in shape for ggplot
tmp2a <- lapply(tmp2, t)
tmp2b <- lapply(tmp2a, as.data.frame)
tmp2c <- lapply(tmp2b, FUN = function(x){
  x$area <- "All study areas"
  x})
tmp5 <- as.data.frame(rbindlist(tmp2c, idcol = "covariate"))

# give proper labels to values in covariate column
tmp5$covariate <- factor(tmp5$covariate, levels = c("E", "L", "V"), labels = c("Elevation", "Least cost path", "Village density"))

# add color information
notbetween95 <- which(!between(0, tmp5$lower95, tmp5$upper95))    # group 1: 95%BCI does not overlap 0 -> red
between95 <- which(between(0, tmp5$lower95, tmp5$upper95))        # group 2: 95%BCI overlaps 0         -> black
between75 <- which(between(0, tmp5$lower75, tmp5$upper75))        # group 3: 50%BCI overlaps 0         -> grey

tmp5$level <- NA
tmp5$level [notbetween95] <- 1
tmp5$level [between95] <- 2
tmp5$level [between75] <- 3

# define color values as Hex colors
level <-  rev(c("#A9A9A9", "#000000", "#FF0000")) # grey - black - red

# assign colors in data frame
tmp5$color <- level[tmp5$level]


# plot
p2 <- ggplot(tmp5, mapping = aes(y = median, x = area, group=covariate)) +
  ylim(-2,2)+
  labs(x = "", y = "")+
  geom_hline(yintercept=0, linetype="dashed", color = "grey",size=0.5) +
  geom_pointrange(aes(ymin = lower95, ymax = upper95), size=1, fatten = 5, color=tmp5$color, shape=10) +
  geom_errorbar(aes(ymin = lower75, ymax = upper75), width=0, size=2.2, color=tmp5$color) +
  facet_wrap(facets = ~covariate) +
  theme_bw() +
  coord_flip()+
  theme(axis.title.x=element_text(size=14, vjust=0.5,hjust=0.5),
        axis.ticks.y=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.x=element_text(size=18, angle = 0,vjust=0.3,hjust=1),
        axis.text.y=element_blank(),
        legend.position='bottom',
        panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank(),
        strip.text.x = element_text(size = 30, colour = "black", angle = 00),
        panel.grid.minor.x = element_blank()
  );p2





#####  response curves for all covariates
# one covariate is varies from it's lowest to highest value, the other remain at 0 (their mean)
# make newdata (vary one covariate, other covariates = 0 (at their mean))
nd1 <- expand.grid(list(site = unique(Site_Covs_all_short$site),
                        L = 0,
                        E = seq(min(Site_Covs_all_short$E), max(Site_Covs_all_short$E), length.out = 100),
                        V = 0,
                        covariate = "Elevation"))

nd2 <- expand.grid(list(site = unique(Site_Covs_all_short$site),
                        L = seq(min(Site_Covs_all_short$L), max(Site_Covs_all_short$L), length.out = 100),
                        E = 0,
                        V = 0,
                        covariate = "Least cost path"))

nd3 <- expand.grid(list(site = unique(Site_Covs_all_short$site),
                        L = 0,
                        E = 0,
                        V = seq(min(Site_Covs_all_short$V), max(Site_Covs_all_short$V), length.out = 100),
                        covariate = "Village density"))

# combine prediction data frames for all 3 covariates
nd <- rbind(nd1, nd2, nd3)


# add covariates in their original scale to data frame
nd$ele <- nd$E * attr(scale(Site_Covs_all$ele), "scaled:scale") + attr(scale(Site_Covs_all$ele), "scaled:center")
nd$LCP <- nd$L * attr(scale(Site_Covs_all$LCP), "scaled:scale") + attr(scale(Site_Covs_all$LCP), "scaled:center")
nd$vill <- nd$V * attr(scale(Site_Covs_all$vill), "scaled:scale") + attr(scale(Site_Covs_all$vill), "scaled:center")


##For random effect
# prediction for covariate (one at a time, while to other are 0 = their mean)
# this gives warning, but still works. Strange.
prediction1 <- ubms::predict(
  o_mul_04,
  submodel = "state",
  newdata = nd
)

# change column names (ggplot doesn't like % in column names)
colnames(prediction1) <- c("Predicted",  "SD", "lower", "upper")



# convert scaled covariates back to original scale
nd$covariate_value <- ifelse(nd$covariate == "Least cost path", nd$LCP,
                             ifelse(nd$covariate == "Elevation", nd$ele,
                                    ifelse(nd$covariate == "Village density", nd$vill, NA)))

# combine predition and covariate data frame
prediction1 <- cbind(prediction1, nd)
prediction1$site <- factor(prediction1$site , levels = c("PMNP", "PDNR", "XeSap", "Saola", "BachMa", "STNR"))

# plot responses for all covariates covariates
response_plot1 <- ggplot(prediction1, mapping = aes(x = covariate_value, y = Predicted, color = site)) +
  labs(x = "Covariate value", y = "")+
  geom_ribbon(mapping = aes(ymin = lower,  ymax = upper), alpha = 0.05) +
  geom_line(size = 2) +
  ylim(0,1) +
  facet_wrap(~covariate, nrow = 1, scales = "free_x")+
  theme_bw() +
  theme(strip.text.x = element_text(size = 30, colour = "black", angle = 00),
        axis.text.x=element_text(size=14, angle = 0,vjust=0.3,hjust=1),
        axis.text.y=element_text(size=16, vjust=0.5,hjust=1),
        axis.title.x=element_text(size=14, vjust=0.5,hjust=0.5)
  );response_plot1


# For fixed effect
# prediction for covariate (one at a time, while to other are 0 = their mean)
# this gives warning, but still works. Strange.
prediction2 <- ubms::predict(
  o_mul_01,
  submodel = "state",
  newdata = nd
)

# change column names (ggplot doesn't like % in column names)
colnames(prediction2) <- c("Predicted",  "SD", "lower", "upper")



# convert scaled covariates back to original scale
nd$covariate_value <- ifelse(nd$covariate == "Least cost path", nd$LCP,
                             ifelse(nd$covariate == "Elevation", nd$ele,
                                    ifelse(nd$covariate == "Village density", nd$vill, NA)))

# combine predition and covariate data frame "PMNP", "PDNR", "XeSap", "Saola", "BachMa", "STNR"
prediction2 <- cbind(prediction2, nd)
prediction2$site <- factor(prediction2$site , levels = c("PMNP", "PDNR", "XeSap", "Saola", "BachMa", "STNR"))

# plot responses for all covariates covariates
response_plot2 <- ggplot(prediction2, mapping = aes(x = covariate_value, y = Predicted, color = site)) +
  labs(x = "Covariate value", y = "")+
  geom_ribbon(mapping = aes(ymin = lower,  ymax = upper), alpha = 0.05) +
  geom_line(size = 2) +
  ylim(0,1) +
  facet_wrap(~covariate, nrow = 1, scales = "free_x")+
  theme_bw() +
  theme(strip.text.x = element_text(size = 30, colour = "black", angle = 00),
        axis.text.x=element_text(size=14, angle = 0,vjust=0.3,hjust=1),
        axis.text.y=element_text(size=16, vjust=0.5,hjust=1),
        #axis.text.y=element_blank(), # adjust the y axis label
        axis.title.x=element_text(size=14, vjust=0.5,hjust=0.5)
  );response_plot2

